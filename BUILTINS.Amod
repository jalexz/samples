(******************************************************************************** * The following is an extract from my master thesis work in Computer Science 	*  * and Engineering at ETH Zurich in 2009.										* * It is a module of builtin functions for a custom Oberon compiler targeted	* * for an experimental many-core architecture on a FPGA board. It is written in * * an assembly language that I also designed and implemented as part of my work.* * The functions implements the communication protocol between the cores of the * * board.                                                                       * ********************************************************************************)MODULE BUILTINS;LITERAL	(* ROR values for selecting header fields *)	HPRT = 24;	HLEN = 16;	HSRC = 8;	NEXTFLD = 8;	(* Masks to extract the 8 least significant bits of a word. *)	FLDMSK = 0FFH;	(* Like FLDMSK but discards the 2 least significant bits. Useful for subsequent divisions by 4. *)	FLDMSK2 = 0FCH;	(* Size in words of a ring buffer. Is a power of two in order to make modular arithmetics simpler. *)	IBUFSIZE = 64;		(* Input buffer. *)	OBUFSIZE = 32;		(* Output buffer. *)	(* Mask for arithmetic modulus BUFSIZE *)	IBUFSIZEMSK =	IBUFSIZE - 1;	OBUFSIZEMSK = OBUFSIZE - 1;	(* Registers of I/O ports. *)	DREG = 0;	(* Data register. *)	CREG = 1;	(* Command register. *)	(* Constants used to set/unset fields of I/O port registers. *)	BIT0 = 1H;	BIT1 = 2H;	BIT2 = 4H;	BIT4 = 10H;	BIT5 = 20H;	(* Error codes for exit status of SEND and RECEIVE. *)	NOERROR = 0;	UNFITTING = 1;		(* Received data is of the correct type but longer than requested. *)	WRONGTYPE = 2;	(* Received data is of the wrong type. *)	EMPTYBUFFER = 3;	(* The input buffer was empty and the RECEIVE call was not blocking. *)	MAXINPORTS = 12;	(* Maximum number of input or inout ports. *)	(* Maximum size of the input buffers memory block. *)	MAXINBUFBLOCKSIZE = (IBUFSIZE+2)*MAXINPORTS;	(* Max high level payload length, in words. *)	MAXPLDW = 29;		(* 29 + type hash + low level header = 31 words. In this way 2 31-words packet can fit in a buffer of 64 words. *)	(* Max payload length, in bytes. *)	MAXPLDB = MAXPLDW * 4;	REGISTER	GB = R13; SP = R14; LNK = R15;(* Data segment declared as relocatable: it's up to the programmer to guarantee that the data    segment can be relocated to a start address different from 0. *)DATASEG RELOCATABLE	(* The following three variables will be set by the linker. Do not change	    their offset! *)	SPINIT:				1,			0;		(* Stack pointer bottom. Offset: 0. *)	INBUFBLOCKSIZE:	1,			0;		(* Actual size of the input buffers memory block. Offset: 1.*)	MEP:				1,			0;		(* Main program entry point. Offset: 2 *)	(* Addresses of I/O ports *)	NNODE:	1,			0F02H;	(* netNode address *)	(* Old Global pointer *)	oldGb:		1,			0;	(* Old Stack pointer *)	oldSp:		1,			0;	(* Old link *)	oldLnk:		1,			0;	(* Output buffer *)	obStart:		1,			0;	obEnd:		1,			0;	outBuf:		OBUFSIZE,	0;	(* Used by SendMsg debug procedure.	    Uncomment if necessary.	header:		010C000B; *)	(* Used by sendRS232 debug procedure.	    Uncomment if necessary.	RS232:			1,		0F04H;	dbg:			8,		0; *)	(* Input buffer block: can contain at most MAXINPORTS buffers with their pointers:	    ---	    start pointer of buffer 0	    end pointer of  buffer  0	    buffer 0 (bound to port 0)	    ...	    start pointer of buffer MAXINPORTS-1	    end pointer of buffer MAXINPORTS-1	    buffer MAXINPORTS-1 (bound to port MAXINPORTS-1)	    ---	    This block MUST be declared at last, because the linker will reuse the space of unused	    buffers. *)	inBufsBlock:	MAXINBUFBLOCKSIZE,	0;END;(* Code segment declared as relocatable: it's up to the programmer to guarantee that the code    segment can be relocated to a start address different from 0. *)CODESEG RELOCATABLE		(* Main procedure of the run time system:	      - Initialize the global memory used by system procedures and by the I/O handlers;	      - Call the body of the main module. *)	RUNTIMEMAIN*:		(* Load the pointer to the own data memory segment start address. *)  		LDSS	GB;  		  		(* Initialize the SP register. *)  		LD		SP,		GB,		SPINIT;  		  		(* Initialize the pointers of the output buffer. *)		ADD	R1,		GB,		outBuf;		ST		R1,		GB,		obStart;		ST		R1,		GB,		obEnd;		(* Initialize the pointers of the input buffers. *)		LIT		R1,		inBufsBlock;		ADD	R1,		R1,		GB;		LD		R4,		GB,		INBUFBLOCKSIZE;		ADD	R4,		R4,		R1;		InitLoop:			SUB	R2,		R1,		R4;			BC		GEQ,	ExitLoop;			ADD	R2,		R1,		2;	(* Lowest address of the input buffer. *)			ST		R2,		R1,		0;	(* Initialize the start pointer. *)			ST		R2,		R1,		1;	(* Initialize the end pointer. *)			LIT		R3,		IBUFSIZE;			ADD	R1,		R2,		R3;			BC		FALSE,	InitLoop;		ExitLoop:		  				(* Enable the interrupt #2. *)  		LD		R0,		GB,		NNODE;	(* Load the netNode command register in R0. *)		LD		R1,		R0,		CREG;				OR		R1,		R1,		BIT4;		(* Set to 1 the bit 4 of the netNode command register. *)		ST		R1,		R0,		CREG;		(* Store the new netNode command register. *)						(* Enable the interrupt #3. *)  		LIT		R2,		BIT5;  		LD		R0,		GB,		NNODE;	(* Load the netNode command register in R0. *)		LD		R1,		R0,		CREG;				OR		R1,		R1,		R2;			(* Set to 1 the bit 5 of the netNode command register. *)		ST		R1,		R0,		CREG;		(* Store the new netNode command register. *)				(* Enable the global interrupt. *)  		RBGI 	0,		1;  		  		  		(* Call the body of the main module. *)		LD		R0,		GB,		MEP;		BLR		R0;				(* Restore the GB register. *)  		LDSS	GB;  				(* Infinite loop. *)		loopForever:			BC	FALSE,	loopForever;				(* SEND - Send data through a port.		Input parameters (the content of these register will be changed by the procedure):	     		R0: the destination of the data: coreId (most significant 2 bytes), portId (least significant 2 bytes).	     		      WARNING: since the actual length of the header fields that will store these info is 1 byte,	     		                         only the first byte of each value is taken.  			R1: the address of the variable on which data are stored.  			R2: hash value of the type of the sending data.  			R3: bytes to be sent on the port.  			R4: the address of the variable on which the exit status of the procedure will be stored.  		Used registers:  			R5-R12 (caller-save) R13-R15 (callee-save) *)  	SEND*:  		(* Save the old data global pointer in R5 and set the own. *)  		ADD	R5,		GB,		0;  		LDSS	GB;  		(* Save the return address of the caller. *)  		ST		LNK,	GB,		oldLnk;  		(* Save the old global pointer in memory. *)  		ST		R5,		GB,		oldGb;  		(* Save the old SP pointer. *)  		ST		SP,		GB,		oldSp;  		  		(* Store the exit status: always 0 at the moment. Input in R4 is no longer needed. *)  		LIT		R5,		NOERROR;  		ST		R5,		R4,		0;  		  		(* Build the message header in R8*)  		LIT		R8,		0;					(* SRC = 0, will be set by hardware; LEN = 0, will be set later *)  		ROR	R8,		R8,		16;  		LIT		R6,		FLDMSK;  		AND	R6,		R0,		R6;			(* R6 = portId *)  		ADD	R8,		R8,		R6;			(* PORT = R6 *)  		ROR	R8,		R8,		NEXTFLD;  		ROR	R0,		R0,		16;			(* R6 = coreId *)  		LIT		R6,		FLDMSK;  		AND	R6,		R0,		R6;  		ADD	R8,		R8,		R6;			(* DEST = R6 *)  		(* The input in R0 in no longer needed, so R0 = header. *)  		ADD	R0,		R8,		0;  		  		(* R12: data to be still sent on the port. Input in R3 is no longer needed. *)  		ADD	R12,	R3,		0;  		  		(* Save the value of R1 and set R1 = type hash. Input in R2 is no longer needed. *)  		ADD	R3,		R1,		0;  		ADD	R1,		R2,		0;  		  		(* R2 = payload address. *)  		ADD	R2,		R3,		0;  		  		(* At this point, register R0..R2, LNK are used as input parameters for the procedure OBProduce,  		    R3..R11 will be overwritten by OBProduce so can only be used for temp values, R12 counts the data  		    to be still sent on the port, R14 will store the size of the high level payload (in byte) of the last sent network packet. *)  		      		(* Send the data using network packets of MTU = MAXPLDB + 8 bytes. *)  		SENDSendData:  			ADD	R14,	R12,	0;		(* R14 = min{R12, MAXPLDB} *)  			LIT		R6,		MAXPLDB;  			SUB	R7,		R14	,	R6;  			BC		LEQ,	1;  			ADD	R14,	R6,		0;  			ADD	R5,		R14,	4;		(* R5 = len(payload + hash type) in bytes *)  	 	    	ROR	R5,		R5,		HLEN;	(* LEN = R5 *)  			LIT		R6,		0FFH;  			ROR	R6,		R6,		HLEN;  			BIC		R0,		R0,		R6;	  			ADD	R0,		R0,		R5;  			BL	OBProduce;					(* Create a new network packet and put it in the output buffer. *)  			(* BL		printOBProduce; *)  			LIT		R5,		3;				(* R5 = R14 / 4 *)  			BIC		R5,		R14,	R5;  			ROR	R5,		R5,		2;  			ADD	R2,		R2,		R5;		(* Increment R2. *)  			SUB	R12,	R12,	R14;	(* Decrement R12. *)  			SUB	R5,		R12,	0;		(* If R12 > 0 send another packet. *)  			BC		GTR,	SENDSendData;  		 					  		(* Restore the old SP pointer. *)		LD		SP,		GB,		oldSp;		(* Restore the return address of the caller. *)		LD		LNK,	GB,		oldLnk;		(* Restore the old global pointer. *)		LD		GB,		GB,		oldGb;		(* Return to the caller. *)		BR		LNK;		  	  	(* RECEIVE - read data from a port.  	     	Input parameters (the content of these register will be changed by the procedure):  			R0: the id of the input buffer from which data will be read.  			R1: the address of the variable on which received data will be stored.  			R2: hash value used for type checking with received data.  			R3: bytes expected on the port.  			R4: the address of the variable on which the exit status of the procedure will be stored.  			R5: not-zero if the RECEIVE call is blocking.   		Used registers:  			R5-R12 (caller-save) R13-R15 (callee-save) *)  	RECEIVE*:  		(* Save the old data global pointer in R6 and set the own. *)  		ADD	R6,		GB,		0;  		LDSS	GB;  		(* Save the return address of the caller. *)  		ST		LNK,	GB,		oldLnk;  		(* Save the old global pointer in memory. *)  		ST		R6,		GB,		oldGb;  		(* Save the old SP pointer. *)  		ST		SP,		GB,		oldSp;	  		  		(* R0, R1 and R4 are already ok for IBConsume procedure. *)  		  		(* Save the value of R5 in R8. *)  		ADD	R8,		R5,		0;  		  		(* Save the value of R2 in R5 and set R2 = R3 DIV 4. *)  		ADD	R5,		R2,		0;  		ADD	R2,		R3,		0;  		LIT		R6,		3;  		BIC		R2,		R2,		R6;  		ROR	R2,		R2,		2;  		  		(* Set R3 = R5. *)  		ADD	R3,		R5,		0;  		  		(* Read the requested data (hash type + size in bytes) from the specified buffer. *)  		RECEIVEReadData:  		 	BL		IBConsume;			(* R1 and R2 are updated in order to be used in the next call. *)  		 	LD		R5,		R4,		0;	(* Load the exit status. If is different from zero, exit from the loop. *)  		 	SUB	R5,		R5,		0;  		 	BC		NEQ,	RECEIVERExitLoop;  		 	SUB	R5,		R2,		0;	(* If there are still words to be read, continue the loop. *)  			BC		GTR,	RECEIVEReadData;  		RECEIVERExitLoop:  			(* Read process completed. *)  		(* Restore the old SP pointer. *)		LD		SP,		GB,		oldSp;		(* Restore the return address of the caller. *)		LD		LNK,	GB,		oldLnk;		(* Restore the old global pointer. *)		LD		GB,		GB,		oldGb;		(* Return to the caller. *)		BR		LNK;  	  	(* Insert a new message in the output buffer. 	    Input parameters:	    		R0:  	header	[type, len (bytes), src, dest]		 	R1:  	type hash		 	R2:  	payload address		 	LNK:	return address 	    Used registers (caller-save):	    		R3:	old end pointer 'Eo' 	    		R4:	new end pointer 'En'	    		R5:	current start pointer 'S' 	    		R6, R7, R9, R10: temp values	    		R8: len (in words) of the payload + type hash	    		R11: save the return address *)	OBProduce:		(* Save the return address *)		ADD	R11,	LNK,	0;		(* Read Eo *)		LD		R3,		GB,		obEnd;		(* Compute En. *)		ROR	R8,		R0,		HLEN;		(* R8 := len(payload + type hash) in words*)		LIT		R6,		FLDMSK2;		AND	R8,		R8,		R6;		ROR	R8,		R8,		2;		ADD	R4,		R8,		1;			(* R4 := {[Eo + len(payload + type hash + header) - firstBufAddr]  MOD OBUFSIZE} + firstBufAddr *)		ADD	R4,		R4,		R3;		SUB	R4,		R4,		GB;		SUB	R4,		R4,		outBuf;						LIT		R6,		OBUFSIZEMSK;		AND	R4,		R4,		R6;		ADD	R4,		R4,		GB;		ADD	R4,		R4,		outBuf;						(* Wait until there is enough space in the buffer. 		    Used registers:		    		R7: counter of true conditions *)		OBEnoughSpaceCheck:			(* Three conditions are checked, if less than two are  true then there is not enough space. *)			LD		R5,		GB,		obStart;		(* Read S *)			LIT		R7,		0;					(* Initialize the counter *)			OBFirstCond:	 (* S <= Eo *)				SUB	R6,		R5,		R3;				BC		GTR,	OBSecondCond;				ADD	R7,		R7,		1;			OBSecondCond:	(* Eo < En *)				SUB	R6,		R3,		R4;				BC		GEQ,	OBThirdCond;				ADD	R7,		R7,		1;			OBThirdCond:		(* En < S *)				SUB	R6,		R4,		R5;				BC		GEQ,	OBCheckConds;				ADD	R7,		R7,		1;			OBCheckConds:	(* R7 > 1 *)				SUB	R6,		R7,		1;				BC		LEQ,	OBEnoughSpaceCheck;		(* Insert the message in the buffer. 		    Used registers:		    		R6: number of the words of the payload not still written - 1.		    		R7: address of the word in the output buffer to be written.		    		R9: address of the word of the payload to be stored in the buffer. *)		OBInsert:			ADD	R7,		R3,		0;		(* Initialize R7. *)			ST		R0,		R7,		0;		(* Store the message header. *)			BL		OBIncrementR7;		(* Increment R7. *)					ST		R1,		R7,		0;		(* Store the type hash *)			BL		OBIncrementR7;		(* Increment R7. *)					SUB	R6,		R8,		2;		(* Initizlize R6. *)			ADD	R9,		R2,		0;		(* Initialize R9. *)			(* While R6 >= 0 store a word in the buffer. *)			BC		N,		OBProduceFinal;	(* If R6 is < 0 do not enter the loop. *)			OBWhileLoop:					LD		R10,	R9,		0;	(* Load in R10 the payload word. *)					ST		R10,	R7,		0;	(* Store the payload word. *)					BL		OBIncrementR7;	(* Increment R7. *)					ADD	R9,		R9,		1;	(* Increment R9. *)										SUB	R6,		R6,		1;	(* Decrement R6. *)					BC		NN,		OBWhileLoop;	(* If R6 is >= 0 continue the loop. *)		OBProduceFinal:				(* Save En. *)				ST		R4,		GB,		obEnd;				(* Enable the empty hw output message buffer interrupt. *)				LD		R6,		GB,		NNODE;	(* Get the netNode command register. *)				LD		R7,		R6,		CREG;					LIT		R9,		BIT5;				(* Set the bit 5 of the register. *)				OR		R7,		R7,		R9;				ST		R7,		R6,		CREG;				ADD	LNK,	R11,	0;			(* Restore the return address. *)				BR		LNK;						(* Return to the caller. *)		(* Increment the address of the word in the output buffer to be written	    	    Used registers:		    		R7:   address of the word in the output buffer to be written.		    		R10: temp value. *)		OBIncrementR7:			SUB	R7,		R7,		outBuf;		(* R7 := [(R7 + 1 - firstBufAddr) MOD OBUFSIZE] + firstBufAddr *)			SUB	R7,		R7,		GB;			ADD	R7,		R7,		1;			LIT		R10,	OBUFSIZEMSK;			AND	R7,		R7,		R10;			ADD	R7,		R7,		outBuf;			ADD	R7,		R7,		GB;			BR		LNK;			(* Hw output message buffer empty interrupt handler:	    fetch a message from the (software) output buffer and put it on the hw output message	    buffer of the netNode. 	     Input parameters:	    		LNK:  	return address and value of conditional registers	    Used registers (callee-save):	    		R0:		end pointer 'E' 	    		R1:		current start pointer 'S' 	    		R2: 		address of the current word in the output buffer to be read and put in the hw output buffer. 	    		R3: 		message words not yet copied - 1	    		R4:		temp values	    		R5:		address of the netNode	    		R6: 		value of the command register of the address node 	    		R7:		save the return address (?) and the value of conditional registers *)	OBConsume@3:		(* Set the own data global pointer. *)		LDSS	GB;		(* Save the return address and the value of conditional registers. *)		ADD	R7,		LNK,	0;		(* Initialize R5. *)		LD		R5,		GB,		NNODE;		(* Read E and S. *)		LD		R0,		GB,		obEnd;		LD		R1,		GB,		obStart;		(* If E = S then the buffer is empty: disable the hw output message buffer empty interrupt and		    exit. *)		SUB 	R4,		R0,		R1;		BC		EQ,		OBDisable;		(* Initialize R2. *)		ADD	R2,		R1,		0;		(* Initialize R3. *)		LD		R3,		R2,		0;		(* Get the message header. *)		ROR	R3,		R3,		HLEN;	(* Get len(payload + type_hash) = words not yet copied - 1. *)		LIT		R4,		FLDMSK2;		AND	R3,		R3,		R4;		ROR	R3,		R3,		2;		(* Clear the hw input/output message buffer address register of the netNode. *)		LD 		R6,		R5,		CREG;		OR		R6,		R6,		BIT2;	(* Set the bit 2 of the register. *)		ST		R6,		R5,		CREG;		(* While R3 >= 0 store a word in the hw output buffer. *)		OBWhileLoop2:			LD		R4,		R2,		0;		(* Load in R4 the message word. *)			ST		R4,		R5,		DREG;	(* Store the word in the netNode data register. *)			BL		OBIncrementR2;		(* Increment R2. *)			SUB	R3,		R3,		1;		(* Decrement R3. *)			BC		NN,		OBWhileLoop2;	(* If R3 is >= 0 continue the loop. *)		(* Set the new value of the start pointer of the (software) output buffer and store it in memory.. *)		ADD	R1,		R2,		0;		ST		R1,		GB,		obStart;		(* Take the hw output message buffer. *)		LD 		R6,		R5,		CREG;		OR		R6,		R6,		BIT1;	(* Set the bit 1 of the register. *)		ST		R6,		R5,		CREG;		(* If E = S then the buffer is empty: disable the hw output message buffer empty interrupt. *)		SUB 	R4,		R0,		R1;		BC		NEQ,		OBConsumeFinal;		(* Disable the hw output message buffer empty interrupt. *)		OBDisable:			LIT		R4,		BIT5;		(* Unset the bit 5 of the register. *)			LD 		R6,		R5,		CREG;			BIC		R6,		R6,		R4;			ST		R6,		R5,		CREG;		OBConsumeFinal:			(* Restore the return address (?) and the value of conditional registers. *)			ADD	LNK,	R7,		0;			(* Return to the caller. Use the IRET instruction because we are in a interrupt handling routine. *)			IRET	LNK;		(* Increment the address of the word in the output buffer to be read	    	    Used registers:		    		R2: address of the word in the output buffer to be read.		    		R4: temp value. *)		OBIncrementR2:			SUB	R2,		R2,		outBuf;		(* R2 := [(R2 + 1 - firstBufAddr) MOD OBUFSIZE] + firstBufAddr *)			SUB	R2,		R2,		GB;			ADD	R2,		R2,		1;			LIT		R4,		OBUFSIZEMSK;			AND	R2,		R2,		R4;			ADD	R2,		R2,		outBuf;			ADD	R2,		R2,		GB;			BR		LNK;				(* Remove a received message from one of the input buffers. 	    Input parameters:	    		R0:  	id of the input buffer	    		R3:      	type hash	    		R4:		address where to write the exit status	    		R8:        if not-zero, the procedure is blocking, otherwise will exit	    		             with EMPTYBUFFER error if the buffer is empty.		 	LNK:	return address 	    Input/output parameters:	        	R1:		address where to start copying the payload of the message	    		R2:      	words to be still read	    Used registers (caller-save):	             R5:					address of the start pointer	             R6:					start pointer	             R7, R8, R10:       	temp values	             R9:					address of the current word in the input buffer to be read	             R11:				store the old return address *)	IBConsume:		(* Save the return address *)		ADD	R11,	LNK,	0;		(* Compute R5: inBufsBlock + R0*(IBUFSIZE+2). *)		LIT		R7,		IBUFSIZE;		ADD	R7,		R7,		2;		MUL	R7,		R0,		R7;		ADD	R7,		GB,		R7;		LIT		R5,		inBufsBlock;		ADD	R5,		R5,		R7;		(* Load the start pointer *)		LD		R6,		R5,		0;		(* If R8 is not-zero, the call will be blocking, otherwise		    will exit with EMPTYBUFFER error if the buffer is empty. *)		ADD	R8,		R8,		0;    		BC		EQ,		IBEmptyCheck2;		(* Loops until the buffer contains at least one message. *)		IBEmptyCheck:			(* Load the end pointer in R7 *)			LD		R7,		R5,		1;			(* Check if start pointer != end pointer. *)			SUB	R7,		R6,		R7;			BC		EQ,		IBEmptyCheck;		BC		FALSE,		IBTypeCheck;		(* If the buffer is empty, exits with the error EMPTYBUFFER. *)		IBEmptyCheck2:			(* Load the end pointer in R7 *)			LD		R7,		R5,		1;			(* Check if start pointer != end pointer. *)			SUB	R7,		R6,		R7;			BC		EQ,		IBEmptyBuffer;		(* Check if type and size of the message in the buffer is		    consistent with type and size requested. *)		IBTypeCheck:			(* Initialize R9. *)			ADD	R9,		R6,		0;			(* Load the header of the message in R7. *)			LD		R7,		R9,		0;			(* Extract the len of the message payload (in words) and put it in R8. *)			ROR	R7,		R7,		HLEN;			LIT		R8,		FLDMSK2;			AND	R7,		R7,		R8;			ROR	R7,		R7,		2;			SUB	R8,		R7,		1;			(* Save a copy of R8 in R10. *)			ADD	R10,	R8,		0;			(* If the len of the payload is greater than the words to be still read,			    exit with error. *)			SUB	R7,		R8,		R2;			BC		GTR,	IBUnfittingDataSize;			(* Load the type hash of the message in R7. *)			BL		IBIncrementR9;		(* Increment R9. *)			LD		R7,		R9,		0;						(* If the type hash is different from the type hash requested,			    exit with error. *)			SUB	R7,		R7,		R3;			BC		NEQ,	IBWrongType;			BL		IBIncrementR9;				(* Increment R9. *)			SUB	R8,		R8,		1;	(* Decrement R8. *)			BC		N,		IBConsumeFinal;		(* If R8 < 0 end the copy process. *)				(* Copy the payload in memory, starting from address R1. *)		IBCopy:			(* Load M[R9] in R7 and store it in M[R1] *)			LD		R7,		R9,		0;			ST		R7,		R1,		0;			BL		IBIncrementR9;				(* Increment R9. *)			ADD	R1,		R1,		1;			(* Increment R1. *)			SUB	R8,		R8,		1;			(* Decrement R8. *)			BC		NN,		IBCopy;				(* If R8 < 0 end the copy process. *)		SUB	R2,		R2,		R10;		(* Decrement R2. *)		(* Store the exit status. *)		LIT		R7,		NOERROR;		ST		R7,		R4,		0;		IBConsumeFinal:			(* Store the new value of the start pointer. *)			ST		R9,		R5,		0;			(* Enable the taken hw input message buffer interrupt. *)			LD		R7,		GB,		NNODE;	(* Load the netNode command register in R8. *)			LD		R8,		R7,		CREG;				OR		R8,		R8,		BIT4;		(* Set the bit 4 of the register. *)			ST		R8,		R7,		CREG;			ADD	LNK,	R11,	0;			(* Restore the return address. *)			BR		LNK;						(* Return to the caller. *)		(* Increment the address of the word in the input buffer to be read	    	    Used registers:		    		R5: first address of the input buffer - 2		    		R7: temp value.		    		R9: address of the word in the input buffer to be read. *)		IBIncrementR9:			SUB	R9,		R9,		R5;		(* R9 := [(R9 + 1 - firstBufAddr) MOD IBUFSIZE] + firstBufAddr *)			SUB	R9,		R9,		1;			LIT		R7,		IBUFSIZEMSK;			AND	R9,		R9,		R7;			ADD	R9,		R9,		R5;			ADD	R9,		R9,		2;			BR		LNK;			IBUnfittingDataSize:			LIT	R7,		UNFITTING;			BC	FALSE,	IBExitWithErrors;		IBWrongType:			LIT	R7,		WRONGTYPE;		IBExitWithErrors:			(* Store the exit status. *)			ST		R7,		R4,		0;			(* Remove the invalid message: set R9 to the beginning of the next message and jump to IBConsumeFinal. *)			ADD	R9,		R6,		R10;	(* R9 = [(R6 - firstBufAdr + R10 + 2) MOD IBUFSIZE] + firstBufAdr *)			SUB	R9,		R9,		R5;			LIT		R7,		IBUFSIZEMSK;			AND	R9,		R9,		R7;			ADD	R9,		R9,		R5;			ADD	R9,		R9,		2;			BC		FALSE,	IBConsumeFinal;		IBEmptyBuffer:			LIT		R7,		EMPTYBUFFER;			ST		R7,		R4,		0;	(* Store the exit status. *)			ADD	LNK,	R11,	0;	(* Restore the return address. *)			BR		LNK;				(* Return to the caller. *)					(* Hw input message buffer taken interrupt handler:	    store a message from the hardware input buffer of the NetNode 	    in one of the software input buffers.	    Input parameters:	    		LNK:  	return address and value of conditional registers	    Used registers (callee-save):	    		R0:					address of the netNode	    		R1, R6, R8, R9:		temp values	    		R2:					address of the start pointer of the input buffer	    		R3:					old end pointer 'Eo' 	    		R4:					new end pointer 'En'	    		R5:					current start pointer 'S' 	    		R7:					save the return address (?) and the value of conditional registers *)	    IBProduce@2:		(* Set the own data global pointer. *)		LDSS	GB;		(* Save the return address and the value of conditional registers. *)		ADD	R7,		LNK,	0;		(* Initialize R0. *)		LD		R0,		GB,		NNODE;		(* Load the value of the command register of the network node in R1. *)		LD		R1,		R0,		CREG;		(* Clear the hw input/output message buffer address register of the netNode. *)		OR		R1,		R1,		BIT2;	(* Set the bit 2 of the register. *)		ST		R1,		R0,		CREG;		(* Load the message header in R1. *)		LD		R1,		R0,		DREG;		(* Copy the header in R9. *)		ADD	R9,		R1,		0;		(* Compute R2: inBufsBlock + portDest*(IBUFSIZE+2). *)		ROR	R3,		R1,		HPRT;	(* Store the destination port of the message in R3. Use R3 because isn't yet initialized. *)		LIT		R4,		FLDMSK;		(* Use R4 because isn't yet initialized. *)		AND	R3,		R3,		R4;		LIT		R2,		IBUFSIZE;		ADD	R2,		R2,		2;		MUL	R3,		R3,		R2;		ADD	R3,		R3,		GB;		LIT		R2,		inBufsBlock;		ADD	R2,		R2,		R3;		(* Store in R1 the length of the message (header inclusive) in words. *)		ROR	R1,		R1,		HLEN;		LIT		R4,		FLDMSK2;		AND	R1,		R1,		R4;		ROR	R1,		R1,		2;		ADD	R1,		R1,		1;		(* Read Eo *)		LD		R3,		R2,		1;		(* Compute En. *)		ADD	R4,		R1,		R3;		(* R4 := {[Eo + len(payload + type hash + header) - firstBufAddr]  MOD IBUFSIZE} + firstBufAddr *)		SUB	R4,		R4,		R2;		SUB	R4,		R4,		2;						LIT		R8,		IBUFSIZEMSK;		AND	R4,		R4,		R8;		ADD	R4,		R4,		R2;		ADD	R4,		R4,		2;		(* Read S *)		LD		R5,		R2,		0;						(* If there isn't enough free space in the buffer, disable the buffer-taken interrupt and exit.	           Three conditions are checked, if less than two are  true then there is not enough space. 	           Used registers:	           	R6: counter of true conditions	           	R8: temp values. *)		LIT		R6,		0;					(* Initialize the counter: R6. *)		IBFirstCond:	 (* S <= Eo *)			SUB	R8,		R5,		R3;			BC		GTR,	IBSecondCond;			ADD	R6,		R6,		1;		IBSecondCond:	(* Eo < En *)			SUB	R8,		R3,		R4;			BC		GEQ,	IBThirdCond;			ADD	R6,		R6,		1;		IBThirdCond:		(* En < S *)			SUB	R8,		R4,		R5;			BC		GEQ,	IBCheckConds;			ADD	R6,		R6,		1;		IBCheckConds:	(* R6 > 1 *)			SUB	R6,		R6,		1;			BC		LEQ,	IBDisable;		(* En = Eo. *)		ADD	R4,		R3,		0;		(* R1 := words to be still copied - 1. *)		SUB	R1,		R1,		1;		(* Copy the header. *)		ST		R9,		R4,		0;		BL 		IBIncrementR4;		SUB	R1,		R1,		1;		IBCopyLoop:			(* Fetch a word of the message and copy it in the buffer. *)			LD		R8,		R0,		DREG;			ST		R8,		R4,		0;			(* Increment R4. *)			BL		IBIncrementR4;			(* Decrement R1. *)			SUB	R1,		R1,		1;			(* If R1 < 0 the message is copied. *)			BC		NN,		IBCopyLoop;		(* Load the value of the command register of the network node in R1. *)		LD		R1,		R0,		CREG;		(* Clear the register-taken bit of the netNode. *)		BIC		R1,		R1,		BIT0;	(* Clear the bit 0 of the register. *)		ST		R1,		R0,		CREG;		(* Store En *)		ST		R4,		R2,		1;		(* Increment R4. If it's equal to S the the buffer is full and the hw input buffer		    interrupt is disabled. *)		BL		IBIncrementR4;		SUB	R4,		R4,		R5;		BC		NEQ,	IBFinal;		IBDisable:			(* Load the value of the command register of the network node in R1. *)			LD		R1,		R0,		CREG;			BIC		R1,		R1,		BIT4;	(* Unset the bit 4 of the register. *)			ST		R1,		R0,		CREG;		IBFinal:			(* Restore the old return address and return to the caller. *)			ADD	LNK,	R7,		0;			IRET	LNK;	(* IRET is used because this is an interrupt handling procedure. *)		(* Increment the address of the word in the (software) input buffer to be written	    	    Used registers:		    		R2: first address of the input buffer - 2		    		R4: address of the word in the input buffer to be written.		    		R8: temp value. *)		IBIncrementR4:			SUB	R4,		R4,		R2;		(* R4 := [(R4 + 1 - firstBufAddr) MOD IBUFSIZE] + firstBufAddr *)			SUB	R4,		R4,		1;			LIT		R8,		IBUFSIZEMSK;			AND	R4,		R4,		R8;			ADD	R4,		R4,		R2;			ADD	R4,		R4,		2;			BR		LNK;					(* Debug function:	     Write a string representation of a word on the RS232 port (only if the	     core is the 11).	     Register R12: caller save. The word must be stored at location	     dbg + 7. 	     Uncomment if necessary.	sendRS232:	sendRS232Save:		LIT		R12,	dbg;		ADD	R12,	R12,	GB;		ST		R0,		R12,	0;		ST		R1,		R12,	1;		ST		R2,		R12,	2;		ST		R3,		R12,	3;		ST		R4,		R12,	4;		ST		R5,		R12,	5;		ST		R6,		R12,	6;	sendRS232Check:		(* If the core id is 11 then print the word, else exit. *)		LD		R0,		GB,		NNODE;		LD		R1,		R0,		CREG;		ROR	R1,		R1,		8;		LIT		R2,		FLDMSK;		AND	R1,		R1,		R2;		SUB	R1,		R1,		11;		BC		NEQ,	sendRS232End;	sendRS232Init:		LIT		R1,		RS232;		LD		R1,		GB,		R1;		LD		R2,		R12,	7;		ROR	R2,		R2,		28;		LIT		R3,		0FH;		LIT		R4,		7;	sendRS232Wait:		LIT		R0,		RS232;		LD		R0,		GB,		R0;		LD		R0,		R0,		1;		AND	R0,		R0,		BIT1;		BC		EQ,		sendRS232Wait;	sendRS232Encode:		AND	R5,		R2,		R3;		LIT		R6,		30H;		ADD	R5,		R5,		R6;		LIT		R6,		3AH;		SUB	R6,		R5,		R6;		BC		LSS,	sendRS232Write;		ADD	R5,		R5,		7;		sendRS232Write:			ST		R5,		R1,		0;		ROR	R2,		R2,		28;		SUB	R4,		R4,		1;		BC		NN,		sendRS232Wait;			sendRS232Wait2:		LIT		R0,		RS232;		LD		R0,		GB,		R0;		LD		R0,		R0,		1;		AND	R0,		R0,		BIT1;		BC		EQ,		sendRS232Wait2;	sendRS232CR:		LIT		R5,		0DH;		ST		R5,		R1,		0;	sendRS232Wait3:		LIT		R0,		RS232;		LD		R0,		GB,		R0;		LD		R0,		R0,		1;		AND	R0,		R0,		BIT1;		BC		EQ,		sendRS232Wait3;	sendRS232LF:		LIT		R5,		0AH;		ST		R5,		R1,		0;	sendRS232End:		LD		R0,		R12,	0;		LD		R1,		R12,	1;		LD		R2,		R12,	2;		LD		R3,		R12,	3;		LD		R4,		R12,	4;		LD		R5,		R12,	5;		LD		R6,		R12,	6;		BR		LNK; *)			(* Debug function. Send a message to the destination specified	    in the 'header' variable.	    Uncomment if necessary.	SendMsg:			(* Save the return address in R3. *)			ADD	R3,		LNK,	0;						(* Store in R0 the address of netNode. *)			LD		R0,		GB,		NNODE;						(* If the core id is 10 then send the message, else exit. *)			LD		R1,		R0,		CREG;			ROR	R1,		R1,		8;			LIT		R2,		FLDMSK;			AND	R1,		R1,		R2;			SUB	R1,		R1,		10;			BC		NEQ,	SendMsgExit;						(* Wait for output buffer is empty. *)			SendMsgWait1:				LD		R1,		R0,		CREG;				AND	R2,		R1,		BIT1;				BC		NEQ,	SendMsgWait1;						(* Clear output buffer address register. *)			OR		R1,		R1,		BIT2;			ST		R1,		R0,		CREG;						(* Store the header. *)			LIT		R1,		header;			LD		R1,		GB,		R1;			ST		R1,		R0,		DREG;						(* Store payload. *)			LIT		R1,		1;			ST		R1,		R0,		DREG;					LIT		R1,		2;			ST		R1,		R0,		DREG;			LIT		R1,		3;			ST		R1,		R0,		DREG;						(* Take output buffer. *)			LD		R1,		R0,		CREG;			OR		R1,		R1,		BIT1;			ST		R1,		R0,		CREG;						SendMsgExit:				BR		R3;		*)END;END BUILTINS.